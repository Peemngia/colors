<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0">
    <title>Peem's Drawing App - Mobile Optimized</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    
    <style>
        /* ** 1. Global & Mobile-First Styles ** */
        :root {
            --primary-color: #5c6bc0; 
            --secondary-color: #ffa726; 
            --background-light: #f5f7fa; 
            --surface-color: #ffffff; 
            --text-color: #333333;
            --shadow-soft: 0 4px 15px rgba(0, 0, 0, 0.1);
            --border-radius: 10px;
            --control-height: 44px; /* Slightly taller for easy mobile tap */
        }

        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: 'Poppins', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            margin: 0;
            padding: 0;
            background-color: var(--background-light); 
            min-height: 100vh;
            color: var(--text-color);
            overflow-x: hidden; 
        }

        h2 {
            color: var(--primary-color);
            margin: 15px 0;
            font-size: 1.5em; /* Smaller title for mobile */
            font-weight: 700;
        }

        .app-container {
            display: flex;
            flex-direction: column; 
            gap: 12px;
            width: 100%; 
            padding: 0 10px 20px;
        }

        /* ** 2. Control Panel Styles ** */
        .controls, .layer-section {
            padding: 12px;
            background-color: var(--surface-color);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-soft);
            box-sizing: border-box;
        }
        
        /* Mobile Control Grid: 2 columns */
        .controls {
            order: 1;
            display: grid;
            grid-template-columns: repeat(2, 1fr); 
            gap: 10px; 
        }
        
        .control-group { 
            display: flex; 
            flex-direction: column; 
            align-items: flex-start; 
            gap: 4px;
        }
        
        .control-group.full-width { grid-column: span 2; }
        
        .controls label { 
            font-weight: 600; 
            font-size: 0.8em;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        input[type="number"], select, input[type="range"] { 
            padding: 6px 8px;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            width: 100%;
            height: var(--control-height); 
            font-size: 1em;
        }
        
        /* Color Picker Styling */
        .color-picker-wrapper { width: 100%; }
        input[type="color"] { 
            width: 100%; 
            height: var(--control-height); 
            border-radius: 6px;
            border: 1px solid #ccc;
        }
        
        /* Tool Buttons Group - 3 columns for mobile */
        .tool-group-buttons {
            grid-column: span 2; 
            display: grid;
            grid-template-columns: repeat(3, 1fr); 
            gap: 8px; 
            padding-top: 5px;
            border-top: 1px solid #eee;
        }
        
        .tool-button, .action-button, #saveButton, .layer-action-btn, #applyCustomSizeBtn { 
            padding: 8px; 
            border-radius: 8px; 
            font-size: 0.8em; /* Smaller font for better fit */
            height: var(--control-height); 
        }

        .tool-button.active {
            background-color: var(--primary-color);
            color: var(--surface-color);
        }
        
        /* Smudge/Manga Settings - Always full width */
        #smudgeSettingsGroup, #mangaSettingsGroup { grid-column: span 2; }
        
        /* Action Group Styling */
        .action-group {
            grid-column: span 2;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        /* Ensure key action buttons are large enough */
        .action-group > button, .zoom-controls { 
             flex-grow: 1; 
             min-width: 45%; /* Allow wrapping */
        } 
        
        .zoom-controls { 
            display: flex; 
            align-items: center; 
            gap: 5px; 
            justify-content: space-between;
            background-color: #f0f0f0;
            border-radius: 8px;
            padding: 5px;
        }
        #zoomDisplay { font-weight: 600; font-size: 0.85em; }
        .zoom-controls .action-button { width: 35px; padding: 5px; height: 35px; }
        
        /* Color Swatches - 6 columns for dense layout */
        .swatch-group { grid-column: span 2; }
        .color-swatches { 
            display: grid; 
            grid-template-columns: repeat(6, 1fr); 
            gap: 5px; 
        } 
        .swatch { padding-bottom: 100%; border-radius: 4px; }
        #recentColors { min-height: 25px; gap: 8px; }
        .swatch.recent { width: 22px; height: 22px; border-radius: 50%; }

        /* Canvas Size Custom Input */
        .size-custom-input { display: flex; gap: 5px; width: 100%; }
        #applyCustomSizeBtn { width: 100%; }
        
        /* ** 3. Canvas Container ** */
        .canvas-container {
            position: relative;
            width: 100%; /* Fill available width */
            height: 40vh; /* Use percentage of viewport height */
            min-height: 250px; 
            border: 1px solid #e0e0e0;
            box-shadow: var(--shadow-soft); 
            border-radius: var(--border-radius); 
            background-color: var(--surface-color); 
            overflow: hidden; 
            transform-origin: top left; 
            touch-action: none; /* Crucial for preventing default mobile scrolling/zooming */
        }
        
        /* ** 4. Layer Panel Styles (Compact Mobile) ** */
        .layer-section {
            order: 2;
        }
        .layer-panel-title {
            font-size: 1em;
            margin-bottom: 10px;
        }
        #layerListContainer {
            max-height: 150px; /* Reduced height for mobile */
            margin-bottom: 10px;
        }
        .layer-item {
            padding: 8px;
            font-size: 0.9em;
        }
        #layerControls {
            display: flex;
            gap: 8px;
        }
        
        /* ** 5. Desktop/Tablet Overrides (If needed, maintain the previous desktop style for larger screens) ** */
        @media (min-width: 800px) {
             .app-container {
                flex-direction: row; 
                width: 1200px;
                padding: 0;
            }
            .canvas-section { order: 1; width: 800px; }
            .layer-section { order: 2; width: 350px; height: 500px; }
            .canvas-container { width: 800px; height: 500px; height: auto; }
            
            .controls { 
                width: 800px; 
                grid-template-columns: repeat(6, 1fr);
                gap: 12px;
            }
            .control-group:not(.full-width) { grid-column: span 2; }
            .control-group.full-width { grid-column: span 6; }
            .tool-group-buttons { grid-column: span 6; grid-template-columns: repeat(6, 1fr); }
            .action-group { grid-column: span 6; }
            .swatch-group { grid-column: span 3; }
        }
    </style>
</head>
<body>

    <h2><i class="fas fa-palette"></i> Peem's Mobile Sketchpad</h2> 
    
    <div class="app-container">
        
        <div class="canvas-section">
            
            <div class="controls">
                
                <div class="tool-group-buttons">
                    <button id="penTool" class="tool-button active" data-tool="pen"><i class="fas fa-pen"></i> ปากกา</button>
                    <button id="eraserTool" class="tool-button" data-tool="eraser"><i class="fas fa-eraser"></i> ลบ</button>
                    <button id="smudgeTool" class="tool-button" data-tool="smudge"><i class="fas fa-smudge"></i> ปัดสี</button>
                    <button id="pressurePenTool" class="tool-button" data-tool="pressurePen"><i class="fas fa-feather-pointed"></i> มังงะ</button>
                    <button id="fillTool" class="tool-button" data-tool="fill"><i class="fas fa-fill"></i> ถังสี</button>
                    <button id="eyedropperTool" class="tool-button" data-tool="eyedropper"><i class="fas fa-eye-dropper"></i> ดูดสี</button>
                </div>
                
                <div class="control-group">
                    <label for="lineWidth"><i class="fas fa-brush"></i> ขนาดพู่กัน:</label>
                    <input type="number" id="lineWidth" value="8" min="1" max="100">
                </div>
                
                <div class="control-group">
                    <label><i class="fas fa-paint-roller"></i> สี:</label>
                    <div class="color-picker-wrapper">
                         <input type="color" id="colorPicker" value="#000000"> 
                    </div>
                </div>

                <div class="control-group">
                    <label for="opacityRange"><i class="fas fa-fill-drip"></i> ความทึบ: <span id="opacityValue">100%</span></label>
                    <input type="range" id="opacityRange" min="0" max="100" value="100">
                </div>
                
                <div class="control-group" id="previewGroup">
                    <label><i class="fas fa-eye"></i> ตัวอย่าง:</label>
                    <div id="brushPreviewContainer">
                        <canvas id="brushPreview" width="100" height="44"></canvas>
                    </div>
                </div>

                <div class="control-group full-width" id="mangaSettingsGroup" style="display:none;">
                    <label for="pressureSensitivity"><i class="fas fa-pen-nib"></i> ความไวแรงกด (มังงะ): <span id="pressureValue">50%</span></label>
                    <input type="range" id="pressureSensitivity" min="10" max="100" value="50">
                </div>

                <div class="control-group full-width" id="smudgeSettingsGroup" style="display:none;">
                    <label for="smudgeStrength"><i class="fas fa-hand-pointer"></i> ความเข้มปัดสี: <span id="smudgeValue">50%</span></label>
                    <input type="range" id="smudgeStrength" min="10" max="100" value="50">
                </div>
                
                <div class="control-group swatch-group full-width">
                    <label><i class="fas fa-swatchbook"></i> สีด่วน:</label>
                    <div class="color-swatches">
                        <div class="swatch" data-color="#000000" style="background-color: #000000;"></div> 
                        <div class="swatch" data-color="#FFFFFF" style="background-color: #FFFFFF; border: 1px solid #ccc;"></div> 
                        <div class="swatch" data-color="#F44336" style="background-color: #F44336;"></div> 
                        <div class="swatch" data-color="#3F51B5" style="background-color: #3F51B5;"></div> 
                        <div class="swatch" data-color="#4CAF50" style="background-color: #4CAF50;"></div> 
                        <div class="swatch" data-color="#FF9800" style="background-color: #FF9800;"></div> 
                    </div>
                    <div id="recentColors" style="padding-top: 5px;">
                        </div>
                </div>

                <div class="action-group full-width">
                    <button id="undoButton" class="action-button"><i class="fas fa-undo"></i> ย้อนกลับ</button> 
                    <div class="zoom-controls">
                        <button id="zoomOutBtn" class="action-button"><i class="fas fa-minus"></i></button>
                        <span id="zoomDisplay">100%</span>
                        <button id="zoomInBtn" class="action-button"><i class="fas fa-plus"></i></button>
                        <button id="zoomResetBtn" class="action-button"><i class="fas fa-expand"></i></button>
                    </div>
                    <button id="saveButton"><i class="fas fa-save"></i> บันทึก</button>
                </div>
            </div>

            <div class="canvas-container" id="canvasContainer">
                </div>

        </div>

        <div class="layer-section">
            <div id="layerPanel">
                <div class="layer-panel-title"><i class="fas fa-layer-group"></i> ชั้นเลเยอร์ (Layers)</div>
                <div id="layerListContainer">
                    </div>
            </div>
            <div id="layerControls">
                <button id="addLayerBtn" class="layer-action-btn"><i class="fas fa-plus"></i> เพิ่ม</button>
                <button id="removeLayerBtn" class="layer-action-btn" disabled><i class="fas fa-trash-alt"></i> ลบ</button>
                <button id="clearLayerButton" class="layer-action-btn"><i class="fas fa-broom"></i> ล้างเลเยอร์</button> 
            </div>
            
            <div class="control-group full-width" style="padding-top: 15px; border-top: 1px solid #eee; margin-top: 10px;">
                <label for="brushShape"><i class="fas fa-circle"></i> รูปทรงพู่กัน:</label>
                <select id="brushShape">
                    <option value="round">กลม (Round)</option>
                    <option value="square">เหลี่ยม (Square)</option>
                    <option value="butt">แหลม (Butt)</option> 
                    <option value="miter">ตัดเหลี่ยม (Miter)</option> 
                </select>
            </div>
             <div class="control-group full-width" style="padding-top: 10px;">
                <label for="canvasPresetSize"><i class="fas fa-ruler-combined"></i> ขนาดกระดาษ:</label>
                <select id="canvasPresetSize">
                    <option value="800x500">Default (800x500)</option>
                    <option value="1920x1080">Full HD (16:9)</option>
                    <option value="2480x3508">A4 (Portrait 300 DPI)</option>
                    <option value="custom">กำหนดเอง...</option>
                </select>
                <div id="customSizeGroup" style="display:flex; flex-direction: column; gap: 5px; margin-top: 5px;">
                    <div class="size-custom-input">
                         <input type="number" id="customWidth" placeholder="กว้าง" value="800" min="100" max="5000">
                         <input type="number" id="customHeight" placeholder="สูง" value="500" min="100" max="5000">
                    </div>
                    <button id="applyCustomSizeBtn" class="action-button">ปรับขนาด</button>
                </div>
            </div>
        </div>
        
    </div>

    <script>
        // ** Global Constants and Variables **
        
        let WIDTH = 800;
        let HEIGHT = 500;
        const MAX_VELOCITY = 100; 
        const MAX_HISTORY_COLORS = 6; 
        const maxStackSize = 30;
        
        let layers = []; 
        let activeLayerIndex = -1;
        let currentTool = 'pen'; 
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let lastTimestamp = 0; 
        let currentLineWidth = 0; 
        let currentZoom = 1.0;
        let colorHistory = []; 
        let currentStroke = []; 
        let sampledColor = null; 
        let mergedCanvas = null; 
        let mergedCtx = null;

        // Element References
        const canvasContainer = document.getElementById('canvasContainer');
        const colorPicker = document.getElementById('colorPicker');
        const lineWidthInput = document.getElementById('lineWidth');
        const brushShapeSelect = document.getElementById('brushShape'); 
        const opacityRange = document.getElementById('opacityRange'); 
        const pressureSensitivity = document.getElementById('pressureSensitivity');
        const smudgeStrengthInput = document.getElementById('smudgeStrength');

        const PresetSizes = {
            "800x500": { width: 800, height: 500 },
            "1920x1080": { width: 1920, height: 1080 },
            "2480x3508": { width: 2480, height: 3508 },
            "custom": { width: 800, height: 500 }
        };

        // --- Utility Helper Functions ---
        
        // ** MOBILE-FRIENDLY COORDINATE RETRIEVAL **
        function getCoors(e) {
            const coors = e.touches ? e.touches[0] : e;
            const activeLayer = layers[activeLayerIndex];
            if (!activeLayer) return null;
            const rect = activeLayer.canvas.getBoundingClientRect(); 
            // Calculate coordinates relative to the original, unscaled canvas size
            const x = (coors.clientX - rect.left) / currentZoom; 
            const y = (coors.clientY - rect.top) / currentZoom; 
            // Use force for pressure if available on touch devices, otherwise default to 0.5
            const pressure = e.pressure !== undefined ? e.pressure : (e.touches && e.touches[0] && e.touches[0].force > 0 ? e.touches[0].force : 0.5);
            return { x, y, pressure: pressure };
        }

        function rgbToHex(rgbArray) { /* ... unchanged ... */
            const [r, g, b] = rgbArray;
            return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();
        }

        function hexToRgb(hex) { /* ... unchanged ... */
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        function midpoint(p1, p2) { /* ... unchanged ... */
            return { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
        }

        // --- Smudge Tool Core Logic (Unchanged) ---
        
        function updateMergedCanvas() { /* ... unchanged ... */
            if (!mergedCanvas) {
                mergedCanvas = document.createElement('canvas');
                mergedCtx = mergedCanvas.getContext('2d');
            }
            mergedCanvas.width = WIDTH;
            mergedCanvas.height = HEIGHT;
            mergedCtx.clearRect(0, 0, WIDTH, HEIGHT);
            layers.forEach(layer => {
                if (layer.isVisible) { mergedCtx.drawImage(layer.canvas, 0, 0); }
            });
        }
        
        function sampleSmudgeColor(x, y) { /* ... unchanged ... */
            updateMergedCanvas(); 
            try {
                const pixelData = mergedCtx.getImageData(Math.floor(x), Math.floor(y), 1, 1).data;
                if (pixelData[3] > 0) { 
                    sampledColor = {
                        r: pixelData[0],
                        g: pixelData[1],
                        b: pixelData[2],
                        a: pixelData[3] / 255.0 
                    };
                } else {
                    const brushRgb = hexToRgb(colorPicker.value);
                    sampledColor = {
                        r: brushRgb.r,
                        g: brushRgb.g,
                        b: brushRgb.b,
                        a: opacityRange.value / 100 
                    };
                }
            } catch (error) {
                console.error("Error sampling smudge color:", error);
                sampledColor = null; 
            }
        }
        
        function applySmudge(x, y) { /* ... unchanged ... */
            if (!sampledColor) return;
            const activeLayer = layers[activeLayerIndex];
            const ctx = activeLayer.ctx;
            const brushSize = parseInt(lineWidthInput.value);
            const strength = smudgeStrengthInput.value / 100;
            const dx = x - lastX;
            const dy = y - lastY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < 1) return; 
            ctx.globalCompositeOperation = 'source-over';
            ctx.lineCap = brushShapeSelect.value;
            ctx.lineJoin = brushShapeSelect.value === 'butt' ? 'bevel' : brushShapeSelect.value;
            ctx.lineWidth = brushSize;
            const currentRgb = hexToRgb(colorPicker.value);
            const finalR = sampledColor.r * (1 - strength) + currentRgb.r * strength;
            const finalG = sampledColor.g * (1 - strength) + currentRgb.g * strength;
            const finalB = sampledColor.b * (1 - strength) + currentRgb.b * strength;
            const finalA = sampledColor.a + (opacityRange.value / 100) * strength; 
            const finalColor = `rgba(${Math.round(finalR)}, ${Math.round(finalG)}, ${Math.round(finalB)}, ${finalA})`;
            ctx.strokeStyle = finalColor;
            ctx.globalAlpha = 1.0; 
            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(x, y);
            ctx.stroke();
            updateMergedCanvas(); 
            try {
                const pixelData = mergedCtx.getImageData(Math.floor(x), Math.floor(y), 1, 1).data;
                if (pixelData[3] > 0) {
                    sampledColor = {
                        r: pixelData[0],
                        g: pixelData[1],
                        b: pixelData[2],
                        a: pixelData[3] / 255.0 
                    };
                } else {
                     sampledColor = {
                        r: finalR,
                        g: finalG,
                        b: finalB,
                        a: finalA
                    };
                }
            } catch (error) {
                 console.error("Error re-sampling smudge color:", error);
            } 
        }

        // --- Manga Pen Core Logic (Unchanged) ---
        
        function calculateDynamicLineWidth(x, y, timestamp) {
            const distance = Math.sqrt(Math.pow(x - lastX, 2) + Math.pow(y - lastY, 2));
            const timeDiff = timestamp - lastTimestamp;
            let velocity = distance / (timeDiff || 1); 
            velocity = Math.min(velocity, MAX_VELOCITY); 
            const normalizedVelocity = velocity / MAX_VELOCITY; 
            const baseSize = parseInt(lineWidthInput.value);
            const minSize = 0.1; 
            const sensitivity = pressureSensitivity.value / 100;
            const dynamicSize = baseSize * Math.pow((1 - (normalizedVelocity * sensitivity)), 2) + minSize; 
            const smoothingFactor = 0.6; 
            currentLineWidth = currentLineWidth === 0 ? dynamicSize : (currentLineWidth * (1 - smoothingFactor) + dynamicSize * smoothingFactor); 
            const baseOpacity = opacityRange.value / 100;
            const dynamicAlpha = baseOpacity * Math.max(0.9, 1 - normalizedVelocity * 0.1); 
            return { width: Math.max(minSize, currentLineWidth), alpha: dynamicAlpha };
        }
        
        function drawMangaSegment(coors, dynamic) {
            const ctx = layers[activeLayerIndex].ctx;
            let strokeWidth = dynamic.width;
            let alpha = dynamic.alpha;
            currentStroke.push({ x: coors.x, y: coors.y, width: strokeWidth });
            if (currentStroke.length > 2) {
                const p1 = currentStroke[currentStroke.length - 3];
                const p2 = currentStroke[currentStroke.length - 2];
                const p3 = currentStroke[currentStroke.length - 1];
                const mid1 = midpoint(p1, p2);
                const mid2 = midpoint(p2, p3);
                ctx.globalCompositeOperation = 'source-over'; 
                ctx.globalAlpha = alpha; 
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.lineWidth = (p2.width + p3.width) / 2; 
                ctx.beginPath();
                ctx.moveTo(mid1.x, mid1.y); 
                ctx.quadraticCurveTo(p2.x, p2.y, mid2.x, mid2.y);
                ctx.stroke();
            }
        }

        function finalizeMangaStroke() {
             if (currentStroke.length < 2) return;
             const ctx = layers[activeLayerIndex].ctx;
             const len = currentStroke.length;
             const p_last = currentStroke[len - 2]; 
             const p_end = currentStroke[len - 1]; 
             ctx.beginPath();
             ctx.globalAlpha = opacityRange.value / 100;
             ctx.strokeStyle = colorPicker.value;
             ctx.lineWidth = 0.5; 
             ctx.lineCap = 'butt'; 
             ctx.moveTo(p_last.x, p_last.y);
             ctx.lineTo(p_end.x, p_end.y);
             ctx.stroke();
        }

        // --- Core Drawing / Tool Dispatcher (Unchanged) ---
        
        function draw(e) {
            const coors = getCoors(e);
            const activeLayer = layers[activeLayerIndex];
            const timestamp = performance.now();
            
            if (!isDrawing || !activeLayer || !activeLayer.isVisible || !coors) return; 

            const ctx = activeLayer.ctx;

            if (currentTool === 'eraser' || currentTool === 'pen') {
                ctx.globalCompositeOperation = (currentTool === 'eraser') ? 'destination-out' : 'source-over'; 
                ctx.lineWidth = (currentTool === 'eraser') ? parseInt(lineWidthInput.value) * 2 : parseInt(lineWidthInput.value);
                ctx.globalAlpha = (currentTool === 'eraser') ? 1.0 : opacityRange.value / 100; 
                ctx.strokeStyle = (currentTool === 'eraser') ? 'rgba(0,0,0,1)' : colorPicker.value;
                
                ctx.lineCap = brushShapeSelect.value;
                ctx.lineJoin = brushShapeSelect.value === 'butt' ? 'bevel' : brushShapeSelect.value; 
                
                ctx.beginPath();
                ctx.moveTo(lastX, lastY); 
                ctx.lineTo(coors.x, coors.y); 
                ctx.stroke();
            } 
            else if (currentTool === 'pressurePen') {
                const dynamic = calculateDynamicLineWidth(coors.x, coors.y, timestamp);
                ctx.strokeStyle = colorPicker.value;
                drawMangaSegment(coors, dynamic);
            }
            else if (currentTool === 'smudge') {
                applySmudge(coors.x, coors.y);
            }

            [lastX, lastY] = [coors.x, coors.y];
            lastTimestamp = timestamp;
        }

        // --- Event Handlers & Management Functions ---
        
        // ** IMPROVED TOUCH HANDLING **
        function handleStart(e) {
            e.preventDefault(); 
            const activeLayer = layers[activeLayerIndex];
            if (!activeLayer) return;

            const coors = getCoors(e);
            if (!coors) return;
            
            if (currentTool === 'eyedropper') { handleEyedropperClick(e); return; }
            if (currentTool === 'fill') { fillCanvas(e); return; }

            isDrawing = true;
            [lastX, lastY] = [coors.x, coors.y];
            lastTimestamp = performance.now(); 
            currentLineWidth = parseInt(lineWidthInput.value); 
            currentStroke = []; 
            
            if (currentTool === 'pressurePen') {
                 currentStroke.push({ x: coors.x, y: coors.y, width: 0.1 });
            } else if (currentTool === 'smudge') {
                 sampleSmudgeColor(coors.x, coors.y);
            }
            
            draw(e);
        }

        function handleEnd() {
            if (isDrawing) { 
                isDrawing = false; 
                if (currentTool === 'pressurePen' && currentStroke.length > 0) { finalizeMangaStroke(); }
                saveState(); 
                currentLineWidth = 0; 
                currentStroke = []; 
                sampledColor = null; 
            }
        }

        function setTool(toolName) {
            if (currentTool === 'pen' || currentTool === 'pressurePen') {
                 updateColorHistory(colorPicker.value);
            }
            
            currentTool = toolName;
            document.querySelectorAll('.tool-button').forEach(btn => btn.classList.remove('active'));
            document.getElementById(toolName + 'Tool').classList.add('active');
            updateCursor(); 
            updateBrushPreview(); 
            
            // Show/Hide specific settings panels based on tool selection
            document.getElementById('mangaSettingsGroup').style.display = (toolName === 'pressurePen') ? 'flex' : 'none';
            document.getElementById('smudgeSettingsGroup').style.display = (toolName === 'smudge') ? 'flex' : 'none';
        }

        function initContext(ctx) { /* ... unchanged ... */
            ctx.lineCap = brushShapeSelect.value;
            ctx.lineJoin = brushShapeSelect.value === 'butt' ? 'bevel' : brushShapeSelect.value;
            ctx.strokeStyle = colorPicker.value; 
            ctx.lineWidth = lineWidthInput.value;
            ctx.globalAlpha = opacityRange.value / 100;
        }
        
        function addLayer(silent = false) { /* ... unchanged ... */
            const layerId = layers.length + 1;
            const newCanvas = document.createElement('canvas');
            newCanvas.id = `layer${layerId}`;
            newCanvas.className = 'drawing-layer';
            newCanvas.width = WIDTH;
            newCanvas.height = HEIGHT;
            const newCtx = newCanvas.getContext('2d');
            const newLayer = { id: layerId, canvas: newCanvas, ctx: newCtx, undoStack: [], isVisible: true };
            initContext(newCtx); 
            layers.push(newLayer);
            canvasContainer.appendChild(newCanvas);
            updateLayerPanelUI();
            if (layers.length === 1 || !silent) {
                 setActiveLayer(layers.length - 1);
                 if (!silent) { saveState(); }
            } else if (layers.length > 1 && silent) {
                 saveState.call({ layers: layers, activeLayerIndex: layers.length - 1 }); 
            }
        }

        function removeLayer() { /* ... unchanged ... */
            if (layers.length <= 1) { alert("ต้องมีอย่างน้อยหนึ่งเลเยอร์!"); return; }
            const activeLayer = layers[activeLayerIndex];
            const confirmDelete = confirm(`คุณต้องการลบ Layer ${activeLayer.id} ใช่หรือไม่?`);
            if (!confirmDelete) return;
            canvasContainer.removeChild(activeLayer.canvas);
            layers.splice(activeLayerIndex, 1);
            if (activeLayerIndex >= layers.length) { activeLayerIndex = layers.length - 1; }
            setActiveLayer(activeLayerIndex);
            updateLayerPanelUI();
        }

        function setActiveLayer(index) { /* ... unchanged ... */
            if (index < 0 || index >= layers.length) return;
            activeLayerIndex = index;
            layers.forEach((layer, i) => {
                layer.canvas.style.zIndex = (i === index) ? layers.length + 100 : i; 
                layer.canvas.style.pointerEvents = (i === index) ? 'auto' : 'none'; 
            });
            updateCursor();
            updateLayerPanelUI();
        }

        function updateLayerPanelUI() { /* ... unchanged ... */
             const layerListContainer = document.getElementById('layerListContainer');
            const removeLayerBtn = document.getElementById('removeLayerBtn');
            layerListContainer.innerHTML = '';
            layers.slice().reverse().forEach((layer, originalIndex) => {
                const globalIndex = layers.length - 1 - originalIndex; 
                const isCurrent = globalIndex === activeLayerIndex;
                const layerItem = document.createElement('div');
                layerItem.className = `layer-item ${isCurrent ? 'active' : ''}`;
                layerItem.dataset.index = globalIndex;
                const titleGroup = document.createElement('div');
                titleGroup.className = 'layer-title-group';
                const visibilityBtn = document.createElement('button');
                visibilityBtn.className = 'layer-visibility-btn';
                visibilityBtn.innerHTML = layer.isVisible ? '<i class="fas fa-eye"></i>' : '<i class="fas fa-eye-slash"></i>';
                visibilityBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); 
                    layer.isVisible = !layer.isVisible;
                    layer.canvas.style.visibility = layer.isVisible ? 'visible' : 'hidden';
                    updateLayerPanelUI();
                });
                titleGroup.appendChild(visibilityBtn);
                const layerTitle = document.createElement('span');
                layerTitle.textContent = `Layer ${layer.id}`;
                titleGroup.appendChild(layerTitle);
                layerItem.appendChild(titleGroup);
                layerItem.addEventListener('click', () => setActiveLayer(globalIndex));
                layerListContainer.appendChild(layerItem); 
            });
            removeLayerBtn.disabled = layers.length <= 1;
        }

        function saveState() { /* ... unchanged ... */
            const activeLayer = layers[activeLayerIndex];
            if (!activeLayer) return;
            const stack = activeLayer.undoStack;
            if (stack.length >= maxStackSize) { stack.shift(); }
            stack.push(activeLayer.canvas.toDataURL());
        }

        function undoLastAction() { /* ... unchanged ... */
            const activeLayer = layers[activeLayerIndex];
            if (!activeLayer) return;
            const stack = activeLayer.undoStack;
            if (stack.length > 1) { 
                stack.pop(); 
                const lastState = stack[stack.length - 1]; 
                const img = new Image();
                img.onload = function() {
                    activeLayer.ctx.clearRect(0, 0, WIDTH, HEIGHT);
                    activeLayer.ctx.drawImage(img, 0, 0);
                };
                img.src = lastState;
            } else if (stack.length === 1) {
                activeLayer.ctx.clearRect(0, 0, WIDTH, HEIGHT);
                stack.pop(); 
                saveState(); 
            }
        }
        
        function clearCanvas() { /* ... unchanged ... */
            const activeLayer = layers[activeLayerIndex];
            if (!activeLayer) return;
            activeLayer.ctx.clearRect(0, 0, WIDTH, HEIGHT);
            saveState(); 
        }

        function fillCanvas(e) { /* ... unchanged ... */
            const activeLayer = layers[activeLayerIndex];
            if (currentTool !== 'fill' || !activeLayer || !activeLayer.isVisible) return;
            const ctx = activeLayer.ctx;
            ctx.globalCompositeOperation = 'source-over';
            ctx.fillStyle = colorPicker.value;
            ctx.globalAlpha = opacityRange.value / 100;
            ctx.fillRect(0, 0, WIDTH, HEIGHT); 
            saveState();
        }

        function handleEyedropperClick(e) { /* ... unchanged ... */
            if (currentTool !== 'eyedropper') return;
            const coors = getCoors(e);
            if (!coors) return;
            const x = Math.floor(coors.x);
            const y = Math.floor(coors.y);
            updateMergedCanvas(); 
            const pixelData = mergedCtx.getImageData(x, y, 1, 1).data;
            const newHexColor = rgbToHex(pixelData);
            updateColorHistory(newHexColor);
            colorPicker.value = newHexColor;
            setTool('pen'); 
        }

        function updateColorHistory(newColor) { /* ... unchanged ... */
            const index = colorHistory.indexOf(newColor);
            if (index > -1) { colorHistory.splice(index, 1); } 
            else if (colorHistory.length >= MAX_HISTORY_COLORS) { colorHistory.pop(); }
            colorHistory.unshift(newColor);
            renderColorHistory();
        }

        function renderColorHistory() { /* ... unchanged ... */
            const recentColorsContainer = document.getElementById('recentColors');
            recentColorsContainer.innerHTML = '';
            document.querySelectorAll('.color-swatches .swatch').forEach(swatch => {
                swatch.onclick = () => { colorPicker.value = swatch.getAttribute('data-color'); setTool('pen'); updateColorHistory(colorPicker.value); };
            });
            colorHistory.forEach(color => {
                const swatch = document.createElement('div');
                swatch.className = 'swatch recent';
                swatch.style.backgroundColor = color;
                swatch.setAttribute('data-color', color);
                swatch.addEventListener('click', () => { colorPicker.value = color; setTool('pen'); });
                recentColorsContainer.appendChild(swatch);
            });
        }
        
        function updateBrushPreview() { /* ... unchanged ... */
            const brushPreviewCanvas = document.getElementById('brushPreview'); 
            const previewCtx = brushPreviewCanvas.getContext('2d');
            const previewWidth = brushPreviewCanvas.width;
            const previewHeight = brushPreviewCanvas.height;
            const size = parseInt(lineWidthInput.value);
            const shape = brushShapeSelect.value;
            const alpha = opacityRange.value / 100;
            previewCtx.clearRect(0, 0, previewWidth, previewHeight);
            const effectiveSize = (currentTool === 'eraser') ? size * 2 : size;
            const brushAlpha = (currentTool === 'eraser') ? 1.0 : alpha;
            previewCtx.fillStyle = (currentTool === 'eraser') ? 'rgba(200, 200, 200, 1)' : colorPicker.value;
            previewCtx.globalAlpha = brushAlpha;
            const centerX = previewWidth / 2;
            const centerY = previewHeight / 2;
            if (shape === 'round') {
                previewCtx.beginPath();
                previewCtx.arc(centerX, centerY, effectiveSize / 2, 0, Math.PI * 2);
                previewCtx.fill();
            } else if (shape === 'square') {
                previewCtx.fillRect(centerX - effectiveSize / 2, centerY - effectiveSize / 2, effectiveSize, effectiveSize);
            } else if (shape === 'butt' || shape === 'miter') {
                previewCtx.beginPath();
                previewCtx.strokeStyle = previewCtx.fillStyle;
                previewCtx.lineWidth = effectiveSize;
                previewCtx.lineCap = shape;
                previewCtx.lineJoin = shape === 'butt' ? 'bevel' : shape;
                const lineLength = 20;
                previewCtx.moveTo(centerX - lineLength / 2, centerY);
                previewCtx.lineTo(centerX + lineLength / 2, centerY);
                previewCtx.stroke();
            }
            previewCtx.globalAlpha = 1.0; 
        }

        function updateZoom(factor) { /* ... unchanged ... */
            const zoomDisplay = document.getElementById('zoomDisplay');
            const MAX_ZOOM = 3.0;
            const MIN_ZOOM = 0.3;
            currentZoom = Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, currentZoom + factor));
            canvasContainer.style.transform = `scale(${currentZoom})`;
            zoomDisplay.textContent = `${Math.round(currentZoom * 100)}%`; 
        }
        
        function resetZoom() { /* ... unchanged ... */
            const zoomDisplay = document.getElementById('zoomDisplay');
            currentZoom = 1.0;
            canvasContainer.style.transform = 'scale(1.0)';
            zoomDisplay.textContent = '100%';
        }
        
        // ** IMPROVED CANVAS RESIZING FOR MOBILE **
        function resizeCanvasContainer() {
            const zoomDisplay = document.getElementById('zoomDisplay');
            const isDesktop = window.innerWidth >= 800;
            
            if (isDesktop) {
                // Desktop mode: Fixed size based on WIDTH/HEIGHT variables
                canvasContainer.style.width = `${WIDTH}px`;
                canvasContainer.style.height = `${HEIGHT}px`;
                resetZoom(); 
                return;
            }
            
            // Mobile mode: Auto-fit canvas container to screen width
            const containerWidth = canvasContainer.parentElement.clientWidth - 20; 
            const newCanvasWidth = Math.min(WIDTH, containerWidth); 
            const newCanvasHeight = newCanvasWidth * (HEIGHT / WIDTH); // Keep aspect ratio
            
            canvasContainer.style.width = `${newCanvasWidth}px`;
            canvasContainer.style.height = `${newCanvasHeight}px`;
            
            currentZoom = newCanvasWidth / WIDTH; // Set zoom factor to match the visual scale
            canvasContainer.style.transform = `scale(${currentZoom})`;
            zoomDisplay.textContent = `${Math.round(currentZoom * 100)}% (Auto)`;
        }


        function resizeAllCanvases(newWidth, newHeight) { /* ... unchanged ... */
            if (newWidth < 100 || newHeight < 100 || newWidth > 5000 || newHeight > 5000) {
                alert("ขนาดต้องอยู่ระหว่าง 100px ถึง 5000px");
                return false;
            }
            const confirmResize = confirm("การเปลี่ยนขนาดกระดาษจะทำให้ภาพที่วาดไปแล้ว (Contents) ถูกลบออก คุณต้องการดำเนินการต่อหรือไม่?");
            if (!confirmResize) { return false; }
            WIDTH = newWidth;
            HEIGHT = newHeight;
            layers.forEach(layer => {
                layer.canvas.width = WIDTH;
                layer.canvas.height = HEIGHT;
                layer.undoStack = [];
                initContext(layer.ctx);
            });
            document.getElementById('customWidth').value = WIDTH;
            document.getElementById('customHeight').value = HEIGHT;
            colorHistory = [];
            renderColorHistory();
            layers.forEach(layer => { layer.undoStack.push(layer.canvas.toDataURL()); }); 
            resizeCanvasContainer();
            alert(`เปลี่ยนขนาดกระดาษเป็น ${WIDTH}x${HEIGHT} (px) แล้ว เนื้อหาถูกลบออกทั้งหมด`);
            return true;
        }

        function handlePresetChange() { /* ... unchanged ... */
            const selectedValue = document.getElementById('canvasPresetSize').value;
            if (selectedValue === 'custom') { 
                document.getElementById('customSizeGroup').style.display = 'flex';
                return; 
            }
            document.getElementById('customSizeGroup').style.display = 'none';
            const size = PresetSizes[selectedValue];
            if (size) { resizeAllCanvases(size.width, size.height); }
        }

        function handleCustomResize() { /* ... unchanged ... */
            const newWidth = parseInt(document.getElementById('customWidth').value);
            const newHeight = parseInt(document.getElementById('customHeight').value);
            if (isNaN(newWidth) || isNaN(newHeight)) { alert("โปรดใส่ค่าตัวเลขที่ถูกต้องสำหรับความกว้างและความสูง"); return; }
            resizeAllCanvases(newWidth, newHeight);
            document.getElementById('canvasPresetSize').value = 'custom'; 
        }

        function mergeAndSave() { /* ... unchanged ... */
            if (layers.length === 0) { alert("ไม่มีเลเยอร์ให้บันทึก!"); return; }
            let fileName = prompt("โปรดตั้งชื่อผลงานของคุณ:", "My_Artwork");
            if (!fileName) { fileName = "Untitled_By_Peem"; }
            const finalCanvas = document.createElement('canvas');
            finalCanvas.width = WIDTH;
            finalCanvas.height = HEIGHT;
            const finalCtx = finalCanvas.getContext('2d');
            layers.forEach(layer => {
                if (layer.isVisible) { finalCtx.drawImage(layer.canvas, 0, 0); }
            });
            const dataURL = finalCanvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.href = dataURL;
            link.download = `${fileName.replace(/ /g, '_')}_${WIDTH}x${HEIGHT}_${Date.now()}.png`; 
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            finalCanvas.remove();
        }

        function updateCursor() { /* ... unchanged ... */
             let cursorStyle = 'crosshair';
             if (currentTool === 'eraser') cursorStyle = 'cell';
             else if (currentTool === 'fill' || currentTool === 'eyedropper' || currentTool === 'smudge') cursorStyle = 'pointer';
            layers.forEach((layer, i) => {
                if (i === activeLayerIndex) {
                    layer.canvas.style.cursor = cursorStyle;
                }
            });
        }


        // --- Event Listener Binding ---

        function setupEventListeners() {
            
            // Mouse Events
            canvasContainer.addEventListener('mousedown', handleStart);
            canvasContainer.addEventListener('mouseup', handleEnd);
            canvasContainer.addEventListener('mousemove', draw);
            canvasContainer.addEventListener('mouseout', handleEnd);
            
            // Touch Events (Crucial for mobile)
            canvasContainer.addEventListener('touchstart', handleStart, { passive: false });
            canvasContainer.addEventListener('touchmove', draw, { passive: false });
            canvasContainer.addEventListener('touchend', handleEnd);
            
            // Tool Buttons
            document.getElementById('penTool').addEventListener('click', () => setTool('pen'));
            document.getElementById('pressurePenTool').addEventListener('click', () => setTool('pressurePen'));
            document.getElementById('eraserTool').addEventListener('click', () => setTool('eraser'));
            document.getElementById('smudgeTool').addEventListener('click', () => setTool('smudge')); 
            document.getElementById('fillTool').addEventListener('click', () => setTool('fill'));
            document.getElementById('eyedropperTool').addEventListener('click', () => setTool('eyedropper'));

            // Settings
            colorPicker.addEventListener('input', updateBrushPreview);
            lineWidthInput.addEventListener('input', updateBrushPreview);
            brushShapeSelect.addEventListener('change', updateBrushPreview);
            
            document.getElementById('opacityRange').addEventListener('input', (e) => {
                document.getElementById('opacityValue').textContent = `${e.target.value}%`;
                updateBrushPreview();
            });
            document.getElementById('pressureSensitivity').addEventListener('input', (e) => {
                document.getElementById('pressureValue').textContent = `${e.target.value}%`;
            });
            document.getElementById('smudgeStrength').addEventListener('input', (e) => { 
                document.getElementById('smudgeValue').textContent = `${e.target.value}%`;
            });
            
            brushShapeSelect.addEventListener('change', () => {
                layers.forEach(layer => { initContext(layer.ctx); }); 
                if (currentTool !== 'fill') { setTool('pen'); }
            });
            
            // Canvas/Action Management
            document.getElementById('canvasPresetSize').addEventListener('change', handlePresetChange);
            document.getElementById('applyCustomSizeBtn').addEventListener('click', handleCustomResize);
            document.getElementById('undoButton').addEventListener('click', undoLastAction); 
            document.getElementById('clearLayerButton').addEventListener('click', clearCanvas); 
            document.getElementById('saveButton').addEventListener('click', mergeAndSave); 
            document.getElementById('zoomInBtn').addEventListener('click', () => updateZoom(0.2));
            document.getElementById('zoomOutBtn').addEventListener('click', () => updateZoom(-0.2));
            document.getElementById('zoomResetBtn').addEventListener('click', resetZoom);

            // Layer Management
            document.getElementById('addLayerBtn').addEventListener('click', () => addLayer(false)); 
            document.getElementById('removeLayerBtn').addEventListener('click', removeLayer); 
            
            window.addEventListener('resize', resizeCanvasContainer);
            
            // Initial UI setup
            renderColorHistory();
            handlePresetChange(); // To hide custom size initially
        }

        // ** 10. Initialization **
        document.addEventListener('DOMContentLoaded', () => {
            WIDTH = PresetSizes["800x500"].width;
            HEIGHT = PresetSizes["800x500"].height;
            setupEventListeners();
            addLayer(true); 
            setTool('pen'); 
            resizeCanvasContainer();
            updateMergedCanvas(); 
        });
    </script>
</body>
</html>
